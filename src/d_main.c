// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------

#define	BGCOLOR		7
#define	FGCOLOR		8

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#include <SDL.h>

#include "doomdef.h"
#include "doomstat.h"

#include "dstrings.h"
#include "sounds.h"

#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "v_video.h"

#include "f_finale.h"
#include "f_wipe.h"

#include "m_argv.h"
#include "m_misc.h"
#include "m_menu.h"

#include "i_system.h"
#include "i_video.h"
#include "i_net.h"
#include "i_audio.h"
#include "i_music.h"
#include "i_cdmus.h"

#include "g_game.h"

#include "hu_stuff.h"
#include "wi_stuff.h"
#include "st_stuff.h"
#include "am_map.h"

#include "p_setup.h"
#include "r_local.h"

#include "d_main.h"

//
// D-DoomLoop()
// Not a globally visible function,
//  just included for source reference,
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls I_GetTime, I_StartFrame, and I_StartTic
//
void D_DoomLoop (void);


char*		wadfiles[MAXWADFILES];


boolean		devparm;	// started game with -devparm
boolean         nomonsters;	// checkparm of -nomonsters
boolean         respawnparm;	// checkparm of -respawn
boolean         fastparm;	// checkparm of -fast
static boolean	store_demo;

boolean         drone;

boolean		singletics = false; // debug flag to cancel adaptiveness



//extern int soundVolume;
//extern  int	sfxVolume;
//extern  int	musicVolume;

extern  boolean	inhelpscreens;

skill_t		startskill;
int             startepisode;
int		startmap;
boolean		autostart;

FILE*		debugfile;

boolean		advancedemo;




char		wadfile[1024];		// primary wad file
char		mapdir[1024];           // directory of development maps
char		basedefault[1024];      // default file

enum {
	IWAD_NAME_DOOM1=0,
	IWAD_NAME_DOOM,
	IWAD_NAME_DOOMU,
	IWAD_NAME_DOOM2,
	IWAD_NAME_DOOM2F,
	IWAD_NAME_PLUTONIA,
	IWAD_NAME_TNT,
	IWAD_NAME_CUSTOM,
	IWAD_NAMES_COUNT
};

static char	*iwad_names[IWAD_NAMES_COUNT]={
	NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL
};

void D_CheckNetGame (void);
void D_ProcessEvents (void);
void G_BuildTiccmd (ticcmd_t* cmd);
void D_DoAdvanceDemo (void);


//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t         events[MAXEVENTS];
int             eventhead;
int 		eventtail;


//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent (event_t* ev)
{
    events[eventhead++] = *ev;
    eventhead &= MAXEVENTS-1;
}


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents (void)
{
	event_t*	ev;

	// IF STORE DEMO, DO NOT ACCEPT INPUT
	if ( store_demo )
		return;

	for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) )
    {
		ev = &events[eventtail];
		if (M_Responder (ev))
			continue;               // menu ate the event
		G_Responder (ev);
	}
}




//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t     wipegamestate = GS_DEMOSCREEN;
extern  boolean setsizeneeded;
extern  int             showMessages;
void R_ExecuteSetViewSize (void);

void D_Display (void)
{
	static  boolean		viewactivestate = false;
	static  boolean		menuactivestate = false;
	static  boolean		inhelpscreensstate = false;
	static  boolean		fullscreen = false;
	static  gamestate_t		oldgamestate = -1;
	static  int			borderdrawcount;
	int				nowtime;
	int				tics;
	int				wipestart;
	int				y;
	boolean			done;
	boolean			wipe;
	boolean			redrawsbar;

	if (nodrawers)
		return;                    // for comparative timing / profiling

	redrawsbar = false;

	// change the view size if needed
	if (setsizeneeded) {
		R_ExecuteSetViewSize ();
		oldgamestate = -1;                      // force background redraw
		borderdrawcount = 3;
	}

	// save the current screen if about to wipe
	if (gamestate != wipegamestate) {
		wipe = true;
		wipe_StartScreen(0, 0, sysvideo.width, sysvideo.height);
	} else
		wipe = false;

	if (gamestate == GS_LEVEL && gametic)
		HU_Erase();

	// do buffered drawing
	switch (gamestate) {
		case GS_LEVEL:
			if (!gametic)
				break;
			if (automapactive)
				AM_Drawer ();
			if (wipe || (viewheight != sysvideo.height && fullscreen) )
				redrawsbar = true;
			if (inhelpscreensstate && !inhelpscreens)
				redrawsbar = true;			// just put away the help screen
			fullscreen = viewheight == sysvideo.height;
			ST_Drawer (fullscreen, redrawsbar );
			break;

		case GS_INTERMISSION:
			WI_Drawer ();
			break;

		case GS_FINALE:
			F_Drawer ();
			break;

		case GS_DEMOSCREEN:
			D_PageDrawer ();
			break;
	}

	// draw the view directly
	if (gamestate == GS_LEVEL && !automapactive && gametic)
		R_RenderPlayerView (&players[displayplayer]);

	if (gamestate == GS_LEVEL && gametic)
		HU_Drawer ();

	// clean up border stuff
	if (gamestate != oldgamestate && gamestate != GS_LEVEL)
		I_SetPalette (W_CacheLumpName ("PLAYPAL",PU_CACHE));

	// see if the border needs to be initially drawn
	if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL) {
		viewactivestate = false;        // view was not active
		R_FillBackScreen ();    // draw the pattern into the back screen
	}

	// see if the border needs to be updated to the screen
	if (gamestate == GS_LEVEL && !automapactive
		&& scaledviewwidth != sysvideo.width)
	{
		if (menuactive || menuactivestate || !viewactivestate)
			borderdrawcount = 3;
		if (borderdrawcount) {
			R_DrawViewBorder ();    // erase old menu stuff
			borderdrawcount--;
		}
	}

	menuactivestate = menuactive;
	viewactivestate = viewactive;
	inhelpscreensstate = inhelpscreens;
	oldgamestate = wipegamestate = gamestate;

	// draw pause pic
	if (paused) {
		y = 4;
		if (!automapactive)
			y += viewwindowy;
		V_DrawPatch(viewwindowx+(scaledviewwidth-68)/2,
			y,0,W_CacheLumpName ("M_PAUSE", PU_CACHE));
	}


	// menus go directly to the screen
	M_Drawer ();          // menu is drawn even on top of everything
	NetUpdate ();         // send out any new accumulation


	// normal update
	if (!wipe) {
		I_FinishUpdate ();              // page flip or blit buffer
		return;
	}

	// wipe update
	wipe_EndScreen(0, 0, sysvideo.width, sysvideo.height);

	wipestart = I_GetTime () - 1;

	do {
		do {
			nowtime = I_GetTime ();
			tics = nowtime - wipestart;
		} while (!tics);
		wipestart = nowtime;
		done = wipe_ScreenWipe(wipe_Melt
			, 0, 0, sysvideo.width, sysvideo.height, tics);
		M_Drawer ();					// menu is drawn even on top of wipes
		I_FinishUpdate ();				// page flip or blit buffer
	} while (!done);
}



//
//  D_DoomLoop
//
extern  boolean         demorecording;

void D_DoomLoop (void)
{
	if (demorecording)
		G_BeginRecording ();

	if (M_CheckParm ("-debugfile")) {
		char    filename[20];
		sprintf (filename,"debug%i.txt",consoleplayer);
		printf ("debug output to: %s\n",filename);
		debugfile = fopen (filename,"w");
	}

	I_InitGraphics ();

	for (;;) {
		// process one or more tics
		if (singletics) {
			I_StartTic ();
			D_ProcessEvents ();
			G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);
			if (advancedemo)
				D_DoAdvanceDemo ();
			M_Ticker ();
			G_Ticker ();
			gametic++;
			maketic++;
		} else {
			TryRunTics (); // will run at least one tic
		}

		S_UpdateSounds (players[consoleplayer].mo);// move positional sounds

		// Update display, next frame, with current state.
		D_Display ();
	}
}



//
//  DEMO LOOP
//
int             demosequence;
int             pagetic;
char                    *pagename;


//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker (void)
{
	if (--pagetic < 0)
		D_AdvanceDemo ();
}



//
// D_PageDrawer
//
void D_PageDrawer (void)
{
    V_DrawPatchDirect (0,0, 0, W_CacheLumpName(pagename, PU_CACHE));
}


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo (void)
{
	advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
 void D_DoAdvanceDemo (void)
{
	players[consoleplayer].playerstate = PST_LIVE;  // not reborn
	advancedemo = false;
	usergame = false;               // no save / end game here
	paused = false;
	gameaction = ga_nothing;

	if ( gamemode == retail )
		demosequence = (demosequence+1)%7;
	else
		demosequence = (demosequence+1)%6;

	switch (demosequence) {
		case 0:
			if ( gamemode == commercial )
				pagetic = TICRATE * 11;
			else
				pagetic = 170;
			gamestate = GS_DEMOSCREEN;
			pagename = "TITLEPIC";
			if ( gamemode == commercial )
				S_StartMusic(mus_dm2ttl);
			else
				S_StartMusic (mus_intro);
			break;
		case 1:
			G_DeferedPlayDemo ("demo1");
			break;
		case 2:
			pagetic = 200;
			gamestate = GS_DEMOSCREEN;
			pagename = "CREDIT";
			break;
		case 3:
			G_DeferedPlayDemo ("demo2");
			break;
		case 4:
			gamestate = GS_DEMOSCREEN;
			if ( gamemode == commercial) {
				pagetic = TICRATE * 11;
				pagename = "TITLEPIC";
				S_StartMusic(mus_dm2ttl);
			} else {
				pagetic = 200;

				if ( gamemode == retail )
					pagename = "CREDIT";
				else
					pagename = "HELP2";
			}
			break;
		case 5:
			G_DeferedPlayDemo ("demo3");
			break;
		// THE DEFINITIVE DOOM Special Edition demo
		case 6:
			G_DeferedPlayDemo ("demo4");
			break;
	}
}



//
// D_StartTitle
//
void D_StartTitle (void)
{
	gameaction = ga_nothing;
	demosequence = -1;
	D_AdvanceDemo ();
}




//      print title for every printed line
char            title[128];



//
// D_AddFile
//
void D_AddFile (char *file)
{
	int     numwadfiles;
	char    *newfile;

	for (numwadfiles = 0 ; wadfiles[numwadfiles] ; numwadfiles++) {
	}

	newfile = malloc (strlen(file)+1);
	strcpy (newfile, file);

	wadfiles[numwadfiles] = newfile;
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
#define ALLOCATE_IWAD_NAME(num_name, filename) \
	{	\
		int length;	\
		\
		length = strlen(doomwaddir)+strlen(filename)+2;	\
		iwad_names[num_name] = malloc(length); \
		sprintf(iwad_names[num_name], "%s/" filename, doomwaddir);	\
		iwad_names[num_name][length-1]='\0';	\
	}

#define ALLOCATE_IWAD_CUSTOM_NAME(num_name, filename) \
	{	\
		int length;	\
		\
		length = strlen(filename)+2;	\
		iwad_names[num_name] = malloc(length); \
		strcpy(iwad_names[num_name], filename);	\
		iwad_names[num_name][length-1]='\0';	\
	}

#define GAME_FILE_DOOM2		"doom2.wad"
#define GAME_FILE_DOOM2F	"doom2f.wad"
#define GAME_FILE_DOOMU		"doomu.wad"
#define GAME_FILE_DOOM		"doom.wad"
#define GAME_FILE_DOOM1		"doom1.wad"
#define GAME_FILE_PLUTONIA	"plutonia.wad"
#define GAME_FILE_TNT		"tnt.wad"

void IdentifyVersion (void)
{
	char *home;
	char *doomwaddir;
	int p;

	gamemode = indetermined;

	doomwaddir = getenv("DOOMWADDIR");
	if (!doomwaddir)
		doomwaddir = ".";

	// Commercial.
	ALLOCATE_IWAD_NAME(IWAD_NAME_DOOM2, GAME_FILE_DOOM2);

	// French version
	ALLOCATE_IWAD_NAME(IWAD_NAME_DOOM2F, GAME_FILE_DOOM2F);

	// Retail.
	ALLOCATE_IWAD_NAME(IWAD_NAME_DOOMU, GAME_FILE_DOOMU);

	// Registered.
	ALLOCATE_IWAD_NAME(IWAD_NAME_DOOM, GAME_FILE_DOOM);

	// Shareware.
	ALLOCATE_IWAD_NAME(IWAD_NAME_DOOM1, GAME_FILE_DOOM1);

	// Plutonia pack
	ALLOCATE_IWAD_NAME(IWAD_NAME_PLUTONIA, GAME_FILE_PLUTONIA);
	
	// Tnt pack
	ALLOCATE_IWAD_NAME(IWAD_NAME_TNT, GAME_FILE_TNT);


	home = getenv("HOME");
	if (!home) {
//		I_Error("Please set $HOME to your home directory");
		sprintf(basedefault, "doom.cfg");
	} else {
		sprintf(basedefault, "%s/.doom", home);
		mkdir(basedefault, 0755);
		sprintf(basedefault, "%s/.doom/doom.cfg", home);
	}

	p = M_CheckParm("-iwad");

	if (M_CheckParm ("-shdev")) {
		gamemode = shareware;
		devparm = true;
		D_AddFile (DEVDATA GAME_FILE_DOOM1);
		D_AddFile (DEVMAPS"data_se/texture1.lmp");
		D_AddFile (DEVMAPS"data_se/pnames.lmp");
		strcpy (basedefault,DEVDATA"default.cfg");
	} else if (M_CheckParm ("-regdev")) {
		gamemode = registered;
		devparm = true;
		D_AddFile (DEVDATA GAME_FILE_DOOM);
		D_AddFile (DEVMAPS"data_se/texture1.lmp");
		D_AddFile (DEVMAPS"data_se/texture2.lmp");
		D_AddFile (DEVMAPS"data_se/pnames.lmp");
		strcpy (basedefault,DEVDATA"default.cfg");
	} else if (M_CheckParm ("-comdev")) {
		gamemode = commercial;
		devparm = true;
		/* I don't bother
		if(plutonia)
			D_AddFile (DEVDATA GAME_FILE_PLUTONIA);
		else if(tnt)
			D_AddFile (DEVDATA GAME_FILE_TNT);
		else*/
			D_AddFile (DEVDATA GAME_FILE_DOOM2);

		D_AddFile (DEVMAPS"cdata/texture1.lmp");
		D_AddFile (DEVMAPS"cdata/pnames.lmp");
		strcpy (basedefault,DEVDATA"default.cfg");
	} else if (p && (p<myargc-1)) {
		char *posname;

		ALLOCATE_IWAD_CUSTOM_NAME(IWAD_NAME_CUSTOM, myargv[p+1]);

		posname = strrchr(iwad_names[IWAD_NAME_CUSTOM], '/');
		if (!posname) {
			posname = strrchr(iwad_names[IWAD_NAME_CUSTOM], '\\');
			if (!posname) {
				posname = iwad_names[IWAD_NAME_CUSTOM];
			} else {
				++posname;
			}
		} else {
			++posname;
		}

		if (strcasecmp(posname, GAME_FILE_DOOM2)==0) {
			gamemode = commercial;
		} else if (strcasecmp(posname, GAME_FILE_DOOM2F)==0) {
			gamemode = commercial;
			language = french;
			printf("French version\n");
		} else if (strcasecmp(posname, GAME_FILE_PLUTONIA)==0) {
			gamemode = commercial;
		} else if (strcasecmp(posname, GAME_FILE_TNT)==0) {
			gamemode = commercial;
		} else if (strcasecmp(posname, GAME_FILE_DOOMU)==0) {
			gamemode = retail;
		} else if (strcasecmp(posname, GAME_FILE_DOOM)==0) {
			gamemode = registered;
		} else if (strcasecmp(posname, GAME_FILE_DOOM1)==0) {
			gamemode = shareware;
		}

		if (gamemode != indetermined) {
			D_AddFile (iwad_names[IWAD_NAME_CUSTOM]);
		}

	} else if ( !access (iwad_names[IWAD_NAME_DOOM2F],R_OK) ) {
		gamemode = commercial;
		// C'est ridicule!
		// Let's handle languages in config files, okay?
		language = french;
		printf("French version\n");
		D_AddFile (iwad_names[IWAD_NAME_DOOM2F]);
	} else if ( !access (iwad_names[IWAD_NAME_DOOM2],R_OK) ) {
		gamemode = commercial;
		D_AddFile (iwad_names[IWAD_NAME_DOOM2]);
	} else if ( !access (iwad_names[IWAD_NAME_PLUTONIA], R_OK ) ) {
		gamemode = commercial;
		D_AddFile (iwad_names[IWAD_NAME_PLUTONIA]);
	} else if ( !access ( iwad_names[IWAD_NAME_TNT], R_OK ) ) {
		gamemode = commercial;
		D_AddFile (iwad_names[IWAD_NAME_TNT]);
	} else if ( !access (iwad_names[IWAD_NAME_DOOMU],R_OK) ) {
		gamemode = retail;
		D_AddFile (iwad_names[IWAD_NAME_DOOMU]);
	} else if ( !access (iwad_names[IWAD_NAME_DOOM],R_OK) ) {
		gamemode = registered;
		D_AddFile (iwad_names[IWAD_NAME_DOOM]);
	} else if ( !access (iwad_names[IWAD_NAME_DOOM1],R_OK) ) {
		gamemode = shareware;
		D_AddFile (iwad_names[IWAD_NAME_DOOM1]);
	} else {
		printf("Game mode indeterminate.\n");
		// We don't abort. Let's see what the PWAD contains.
		//exit(1);
	}
}

//
// Find a Response File
//
void FindResponseFile (void)
{
	int             i;
	char *response_file = NULL;
#define MAXARGVS        100

	for (i = 1;i < myargc;i++) {
		if (myargv[i][0] == '@') {
			response_file = &myargv[i][1];
			break;
		}

		if (strcasecmp("-response", myargv[i])==0) {
			if (i<myargc-1) {
				response_file = &myargv[i+1][0];
				break;
			}
		}
	}

	if (response_file)
		{
			FILE *          handle;
			int             size;
			int             k;
			int             index;
			int             indexinfile;
			char    *infile;
			char    *file;
			char    *moreargs[20];
			char    *firstargv;

			// READ THE RESPONSE FILE INTO MEMORY
			handle = fopen (response_file,"rb");
			if (!handle) {
				I_Error ("\nNo such response file!");
			}
			printf("Found response file %s!\n",response_file);
			fseek (handle,0,SEEK_END);
			size = ftell(handle);
			fseek (handle,0,SEEK_SET);
			file = malloc (size);
			fread (file,size,1,handle);
			fclose (handle);

			// KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
			for (index = 0,k = i+1; k < myargc; k++)
				moreargs[index++] = myargv[k];

			firstargv = myargv[0];
			myargv = malloc(sizeof(char *)*MAXARGVS);
			memset(myargv,0,sizeof(char *)*MAXARGVS);
			myargv[0] = firstargv;

			infile = file;
			indexinfile = k = 0;
			indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)
			do {
				myargv[indexinfile++] = infile+k;
				while(k < size
					&& ((*(infile+k)>= ' '+1) && (*(infile+k)<='z')))
				{
					k++;
				}
				*(infile+k) = 0;
				while(k < size &&
					((*(infile+k)<= ' ') || (*(infile+k)>'z')))
				{
					k++;
				}
			} while(k < size);

			for (k = 0;k < index;k++)
				myargv[indexinfile++] = moreargs[k];
			myargc = indexinfile;

			// DISPLAY ARGS
			printf("%d command-line args:\n",myargc);
			for (k=1;k<myargc;k++)
				printf("%s\n",myargv[k]);
	}
}


//
// D_DoomMain
//
void D_DoomMain (void)
{
    int             p;
    char                    file[256];

    FindResponseFile ();
	
    IdentifyVersion ();
	
    setbuf (stdout, NULL);
    modifiedgame = false;

	p=M_CheckParm ("-width");
    if (p && (p<myargc-1)) {
		sysvideo.width = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-height");
    if (p && (p<myargc-1)) {
		sysvideo.height = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-bpp");
    if (p && (p<myargc-1)) {
		sysvideo.bpp = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-fullscreen");
    if (p) {
		sysvideo.fullscreen = true;
	}
	p=M_CheckParm ("-resize");
    if (p) {
		sysvideo.resize = true;
	}
	p=M_CheckParm ("-flat");
    if (p) {
		sysvideo.textured_spans = false;
	}
	p=M_CheckParm ("-overlay");
    if (p) {
		sysvideo.overlay = sysvideo.resize = true;
	}

	p=M_CheckParm ("-network");
    if (p && (p<myargc-1)) {
		if (strcmp(myargv[p+1],"sting")==0) {
			sysnetwork.layer = NETWORK_STING;
		}
	}

	sysaudio.enabled=true;
	p=M_CheckParm ("-audio");
    if (p && (p<myargc-1)) {
		if (strcmp(myargv[p+1],"off")==0) {
			sysaudio.enabled = false;
		}
	}

	p=M_CheckParm ("-mem");
    if (p && (p<myargc-1)) {
		sysgame.kb_used = atoi(myargv[p+1]);
		if (sysgame.kb_used<MINIMAL_HEAP_SIZE)
			sysgame.kb_used=MINIMAL_HEAP_SIZE;
	}

	p=M_CheckParm ("-cdmusic");
	if (p && (gamemode!=commercial)) {
		i_CDMusic = true;
	}

    nomonsters = M_CheckParm ("-nomonsters");
    respawnparm = M_CheckParm ("-respawn");
    fastparm = M_CheckParm ("-fast");
    devparm = M_CheckParm ("-devparm");
    if (M_CheckParm ("-altdeath"))
	deathmatch = 2;
    else if (M_CheckParm ("-deathmatch"))
	deathmatch = 1;

    switch ( gamemode )
    {
      case retail:
	sprintf (title,
		 "                         "
		 "The Ultimate DOOM Startup v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
      case shareware:
	sprintf (title,
		 "                            "
		 "DOOM Shareware Startup v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
      case registered:
	sprintf (title,
		 "                            "
		 "DOOM Registered Startup v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
      case commercial:
	sprintf (title,
		 "                         "
		 "DOOM 2: Hell on Earth v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
/*FIXME
       case pack_plut:
	sprintf (title,
		 "                   "
		 "DOOM 2: Plutonia Experiment v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
      case pack_tnt:
	sprintf (title,
		 "                     "
		 "DOOM 2: TNT - Evilution v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
*/
      default:
	sprintf (title,
		 "                     "
		 "Public DOOM - v%i.%i"
		 "                           ",
		 DOOM_VERSION/100,DOOM_VERSION%100);
	break;
    }
    
    printf ("%s\n",title);

    if (devparm)
	printf(D_DEVSTR);
    
    if (M_CheckParm("-cdrom"))
    {
	printf(D_CDROM);
	mkdir("c:\\doomdata",0);
	strcpy (basedefault,"c:/doomdata/default.cfg");
    }	
    
    // turbo option
    if ( (p=M_CheckParm ("-turbo")) )
    {
	int     scale = 200;
	extern int forwardmove[2];
	extern int sidemove[2];
	
	if (p<myargc-1)
	    scale = atoi (myargv[p+1]);
	if (scale < 10)
	    scale = 10;
	if (scale > 400)
	    scale = 400;
	printf ("turbo scale: %i%%\n",scale);
	forwardmove[0] = forwardmove[0]*scale/100;
	forwardmove[1] = forwardmove[1]*scale/100;
	sidemove[0] = sidemove[0]*scale/100;
	sidemove[1] = sidemove[1]*scale/100;
    }
    
    // add any files specified on the command line with -file wadfile
    // to the wad list
    //
    // convenience hack to allow -wart e m to add a wad file
    // prepend a tilde to the filename so wadfile will be reloadable
    p = M_CheckParm ("-wart");
    if (p)
    {
	myargv[p][4] = 'p';     // big hack, change to -warp

	// Map name handling.
	switch (gamemode )
	{
	  case shareware:
	  case retail:
	  case registered:
	    sprintf (file,"~"DEVMAPS"E%cM%c.wad",
		     myargv[p+1][0], myargv[p+2][0]);
	    printf("Warping to Episode %s, Map %s.\n",
		   myargv[p+1],myargv[p+2]);
	    break;
	    
	  case commercial:
	  default:
	    p = atoi (myargv[p+1]);
	    if (p<10)
	      sprintf (file,"~"DEVMAPS"cdata/map0%i.wad", p);
	    else
	      sprintf (file,"~"DEVMAPS"cdata/map%i.wad", p);
	    break;
	}
	D_AddFile (file);
    }
	
    p = M_CheckParm ("-file");
    if (p)
    {
	// the parms after p are wadfile/lump names,
	// until end of parms or another - preceded parm
	modifiedgame = true;            // homebrew levels
	while (++p != myargc && myargv[p][0] != '-')
	    D_AddFile (myargv[p]);
    }

    p = M_CheckParm ("-playdemo");

    if (!p)
	p = M_CheckParm ("-timedemo");

    if (p && p < myargc-1)
    {
	sprintf (file,"%s.lmp", myargv[p+1]);
	D_AddFile (file);
	printf("Playing demo %s.lmp.\n",myargv[p+1]);
    }
    
    // get skill / episode / map from parms
    startskill = sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;

		
    p = M_CheckParm ("-skill");
    if (p && p < myargc-1)
    {
	startskill = myargv[p+1][0]-'1';
	autostart = true;
    }

    p = M_CheckParm ("-episode");
    if (p && p < myargc-1)
    {
	startepisode = myargv[p+1][0]-'0';
	startmap = 1;
	autostart = true;
    }
	
    p = M_CheckParm ("-timer");
    if (p && p < myargc-1 && deathmatch)
    {
	int     time;
	time = atoi(myargv[p+1]);
	printf("Levels will end after %d minute",time);
	if (time>1)
	    printf("s");
	printf(".\n");
    }

    p = M_CheckParm ("-avg");
    if (p && p < myargc-1 && deathmatch)
	printf("Austin Virtual Gaming: Levels will end after 20 minutes\n");

    p = M_CheckParm ("-warp");
    if (p && p < myargc-1)
    {
	if (gamemode == commercial)
	    startmap = atoi (myargv[p+1]);
	else
	{
	    startepisode = myargv[p+1][0]-'0';
	    startmap = myargv[p+2][0]-'0';
	}
	autostart = true;
    }
    
    // init subsystems
    printf ("Z_Init: Init zone memory allocation daemon. \n");
    Z_Init ();

    printf ("V_Init: allocate screens.\n");
    V_Init ();

    printf ("M_LoadDefaults: Load system defaults.\n");
    M_LoadDefaults ();              // load before initing other systems

    printf ("W_Init: Init WADfiles.\n");
    W_InitMultipleFiles (wadfiles);
    

    // Check for -file in shareware
    if (modifiedgame)
    {
	// These are the lumps that will be checked in IWAD,
	// if any one is not present, execution will be aborted.
	char name[23][8]=
	{
	    "e2m1","e2m2","e2m3","e2m4","e2m5","e2m6","e2m7","e2m8","e2m9",
	    "e3m1","e3m3","e3m3","e3m4","e3m5","e3m6","e3m7","e3m8","e3m9",
	    "dphoof","bfgga0","heada1","cybra1","spida1d1"
	};
	int i;
	
	if ( gamemode == shareware)
	    I_Error("\nYou cannot -file with the shareware "
		    "version. Register!");

	// Check for fake IWAD with right name,
	// but w/o all the lumps of the registered version. 
	if (gamemode == registered)
	    for (i = 0;i < 23; i++)
		if (W_CheckNumForName(name[i])<0)
		    I_Error("\nThis is not the registered version.");
    }
    
    // Iff additonal PWAD files are used, print modified banner
    if (modifiedgame)
    {
	/*m*/printf (
	    "===========================================================================\n"
	    "ATTENTION:  This version of DOOM has been modified.  If you would like to\n"
	    "get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n"
	    "        You will not receive technical support for modified games.\n"
	    "                      press enter to continue\n"
	    "===========================================================================\n"
	    );
	getchar ();
    }
	

    // Check and print which version is executed.
    switch ( gamemode )
    {
      case shareware:
      case indetermined:
	printf (
	    "===========================================================================\n"
	    "                                Shareware!\n"
	    "===========================================================================\n"
	);
	break;
      case registered:
      case retail:
      case commercial:
	printf (
	    "===========================================================================\n"
	    "                 Commercial product - do not distribute!\n"
	    "         Please report software piracy to the SPA: 1-800-388-PIR8\n"
	    "===========================================================================\n"
	);
	break;
	
      default:
	// Ouch.
	break;
    }

	{
		int i;

		/* Free iwad names */
		for (i=0;i<IWAD_NAMES_COUNT;i++) {
			if (iwad_names[i]) {
				free(iwad_names[i]);
				iwad_names[i]=NULL;
			}
		}

		/* Free wadfile names */
		for (i=0;wadfiles[i];i++) {
			free(wadfiles[i]);
			wadfiles[i]=NULL;
		}
	}


    printf ("M_Init: Init miscellaneous info.\n");
    M_Init ();

    printf ("R_Init: Init DOOM refresh daemon - ");
    R_Init ();

    printf ("\nP_Init: Init Playloop state.\n");
    P_Init ();

    printf ("I_Init: Setting up machine state.\n");
    I_Init ();

    printf ("D_CheckNetGame: Checking network game status.\n");
    D_CheckNetGame ();

    printf ("S_Init: Setting up sound.\n");
    S_Init (snd_SfxVolume /* *8 */, snd_MusicVolume /* *8*/ );

    printf ("HU_Init: Setting up heads up display.\n");
    HU_Init ();

    printf ("ST_Init: Init status bar.\n");
    ST_Init ();

	store_demo = false;
	if ( ( gamemode == commercial ) && (W_CheckNumForName("map01")<0) )
		store_demo = true;

    // check for a driver that wants intermission stats
    p = M_CheckParm ("-statcopy");
    if (p && p<myargc-1)
    {
	// for statistics driver
	extern  void*	statcopy;                            

	statcopy = (void*)atoi(myargv[p+1]);
	printf ("External statistics registered.\n");
    }
    
    // start the apropriate game based on parms
    p = M_CheckParm ("-record");

    if (p && p < myargc-1)
    {
	G_RecordDemo (myargv[p+1]);
	autostart = true;
    }
	
    p = M_CheckParm ("-musexport");
    if (p)
    {
	/* Export MUS files */
	I_ExportMusic();
	I_Quit();
    }

    p = M_CheckParm ("-playdemo");
    if (p && p < myargc-1)
    {
	singledemo = true;              // quit after one demo
	G_DeferedPlayDemo (myargv[p+1]);
	D_DoomLoop ();  // never returns
    }
	
    p = M_CheckParm ("-timedemo");
    if (p && p < myargc-1)
    {
	G_TimeDemo (myargv[p+1]);
	D_DoomLoop ();  // never returns
    }
	
	p = M_CheckParm ("-loadgame");
	if (p && p < myargc-1) {
		if (M_CheckParm("-cdrom"))
			sprintf(file, "c:\\doomdata\\"SAVEGAMENAME"%c.dsg",myargv[p+1][0]);
		else {
			char *home = getenv("HOME");

			if (!home) {
				sprintf(file, SAVEGAMENAME"%c.dsg",myargv[p+1][0]);
			} else {
				sprintf(file, "%s/.doom/"SAVEGAMENAME"%c.dsg",home,myargv[p+1][0]);
			}
		}
		G_LoadGame (file);
	}
	

    if ( gameaction != ga_loadgame )
    {
	if (autostart || netgame)
	    G_InitNew (startskill, startepisode, startmap);
	else
	    D_StartTitle ();                // start up intro loop

    }

    D_DoomLoop ();  // never returns
}
